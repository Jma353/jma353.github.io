---
layout: post
title: Node.js DevOps
---

The following post / documentation outlines development operations for setting up an organized, MVC-driven [`NodeJS`](https://nodejs.org/en/) + [`Express`](http://expressjs.com/) backend.   

# Creation

Run the following command-line arguments (replace install with update if you already have these packages) to establish the project:

{% highlight bash %}
npm install -g express
npm install -g express-generator
express <app-name>
{% endhighlight %}

# MVC File System Setup

This NodeJS configuration features [`Sequelize.js`](http://docs.sequelizejs.com/en/latest/) as an async DB ORM.  Sequelize features a command line interface that can be set up easily via a `.sequelizerc` file in the root of the repository.  Run the following command line arguments to install `Sequelize.js + Sequelize CLI` and create the file (the CLI must be global):

{% highlight bash %}
npm install sequelize --save
npm install -g sequelize-cli
touch .sequelizerc
{% endhighlight %}

Then, add the following lines to `.sequelizerc`:

{% highlight javascript %}
var path = require('path');

module.exports = {
  'config': path.resolve('./config/config.json'),
  'migrations-path': path.resolve('.', 'migrations'),
  'models-path': path.resolve('.', 'models'),
  'seeders-path':path.resolve('.', 'seeders')
}
{% endhighlight %}

The above lines create paths/files for configuration, DB migrations, models, and seeders.  

To initialize the above configuration, run the following argument:

{% highlight bash %}
sequelize init
{% endhighlight %}

Now we have our file system setup well.  

# Configuration

Specific `NPM` packages are necessary for this kind of NodeJS configuration.  

## PostgreSQL Setup

This backend rolls a [`PostgreSQL`](https://www.postgresql.org/) database, but `Sequelize.js` is flexible enough to roll an array of different relational databases.  The above file system setup generated a `/config/config.json` file.  This file allows us to specify databases for various environments we work in.  For now, we will focus on configuring our local development environment.

To install proper NodeJS packages necessary for `Sequelize.js` to interface with a PostgreSQL DB, we must run the following:

{% highlight bash %}
npm install pg --save
npm install pg --hstore
{% endhighlight %}

Following this, we must create our database utilizing the PostgreSQL CLI.  Run the following commands (note `sample_database` should be replaced with the app's DB name)

{% highlight bash %}
psql
CREATE DATABASE sample_database;
\q
{% endhighlight %}

Now, we must configure the `"development"` JSON of the `config.json` file to be the following:

{% highlight bash %}
"development": {
  "database": "sample_database",
  "host": "127.0.0.1",
  "port": "5432",
  "dialect": "postgres"
}
{% endhighlight %}

Note, this assumes one is running a PostgreSQL server LOCALLY on port 5432, the default on installation.

## Database Environment Options

The above allows us to set up our database locally, in `"development"` mode.  To change this configuration and others, check out the `/models/index.js` file generated by the `sequelize init` command.  At the top, you should see lines like these:

{% highlight javascript %}
// Other configs ...
var env       = process.env.NODE_ENV || 'development';
var config    = require(__ dirname + '/../config/config.json')[env];
{% endhighlight %}

This is where general `Sequelize.js` environment specification occurs.  As we can see, the environment defaults to `"development"` if no `NODE_ENV` environment variable is set.  An environment variable like this would normally be set on a server environment, but these types of environment variables are also useful for storing critical API keys and other sensitive credentials locally.  See below for more details on how to set these environment variables.  

## Environment Variables

Thanks to package [`dotenv`](https://github.com/motdotla/dotenv), we can load environment variables into our environment on running our Node JS application locally.  We could always manually export these variables, but keeping all credentials in `.gitignored`-ed file is a more organized approach.  Run the following commands in your project root to set up `dotenv`:

{% highlight bash %}
npm install dotenv --save
touch .env
{% endhighlight %}

Now, you can add keys and credentials to your `.env` file:

{% highlight bash %}
API_KEY=123ABC
DATABASE_PASSWORD=my_password_rocks!
{% endhighlight %}

To have these load automatically on starting your server locally, add the following lines to your `app.js`:

{% highlight javascript %}
var dotenv = require('dotenv');
dotenv.load();
{% endhighlight %}

**NOTE:** Be sure to add `.env` to your `.gitignore` file.  

## Sequelize isUnique Validation Extension

Sequelize is missing an `isUnique` validator, which I personally find essential for specific model validations.  Add this package to include this functionality: [`sequelize-isunique-validator`](https://github.com/angelxmoreno/sequelize-isunique-validator).  

## Sockets

[`Socket.IO`](http://socket.io/) is an extremely useful JS socket library.  Socket.IO can be integrated by first installing it:

{% highlight bash %}
npm install socket.io --save
{% endhighlight %}

In `app.js`, add the following line to initialize Socket.IO:

{% highlight javascript %}
app.io = require('socket.io')();
{% endhighlight %}

Finally, in `/bin/www`, add the line below the pre-written lines shown:

{% highlight javascript %}
// These were generated by initializing the app
server.listen(port, "0.0.0.0");
server.on('error', onError);
server.on('listening', onListening);

// Set Socket.IO
app.io.attach(server);
{% endhighlight %}

Setting up Socket.IO in this way allows us to pass it to routes in the following way:

{% highlight javascript %}
var chats = require('./routes/chats')(app.io);
{% endhighlight %}

This route file can be surrounded by an `exports` function that passes the Socket.IO object into the route file:

{% highlight javascript %}
module.exports = function (io) {
  // Configurations ...  
  var express = require('express');
  var router = express.Router();
  // More configurations


  // Routes + Socket functions

  return router;

}
{% endhighlight %}

For an example, see the [following](https://github.com/Jma353/mini-chat/blob/master/routes/chats.js).

## Passport

[`Passport`](http://passportjs.org/) is a Node JS authentication package that utilizes `strategies` to authenticate via exterior APIs or through custom, app-specific functionality.  To install:

{% highlight bash %}
npm install passport --save
npm install passport-< type of strategy > --save
{% endhighlight %}

Configuration of strategies should occur in `/config/passport.js`.  See the [following](https://github.com/Jma353/mini-chat/blob/master/config/passport.js) for an example on how to do that.  In `app.js`, write the following:

{% highlight javascript %}
var passport = require('passport');
app.use(passport.initialize());
require('./config/passport')(passport);
{% endhighlight %}

## Final app.js

Here is an example of all configs set up in `app.js`:

{% highlight javascript %}
// TO SET ENV VARIABLES
var dotenv = require('dotenv');
dotenv.load();

// TO LOAD PASSPORT
var passport = require('passport');
app.use(passport.initialize());

// CONFIGURE PASSPORT
require('./config/passport')(passport); // Loads custom strategies

// ATTACH SOCKET IO (see www file as well)
app.io = require('socket.io')();

// LOAD ALL ROUTES
var routes = require('./routes/index');
var users = require('./routes/users');
var chats = require('./routes/chats')(app.io);

// REGISTER ROUTES
app.use('/', routes);
app.use('/users', users);
app.use('/chats', chats);
{% endhighlight %}

## Optional: Server Restart on File Change

When developing, it might be useful to have the server restart on file changes to ensure that you're not trying to debug something you already fixed without restarting the server.  [`Nodemon`](https://github.com/remy/nodemon) tracks file changes and restarts your server as necessary.  To install (globally):

{% highlight bash %}
npm install -g nodemon
{% endhighlight %}

In `package.json`, change the `"scripts"` JSON `"start"` command:

{% highlight bash %}
"start": "nodemon ./bin/www"
{% endhighlight %}

## Testing

TDD / BDD is crucial for an API.  In general, as stated by Ted Dumitrescu in his [blog](http://cmme.org/tdumitrescu/blog/2014/02/node-sql-testing/) about testing Node JS applications, testing configurations should:

* Involve a separate "test" DB (other than the one being used for development)
* Never depend on other tests' states
* Clear and rebuild the database before each test

This setup sticks to these paradigms.  Much like we created a `"development"` database above in our `/config/config.json` file, we must do the same for our `"test"` database.  Here is a suggested configuration:

{% highlight bash %}
"test": {
  "database": "sample_database_test",
  "host": "127.0.0.1",
  "port": "5432",
  "dialect": "postgres"
}
{% endhighlight %}

Now, the packages [`Mocha`](https://github.com/mochajs/mocha), [`Supertest`](https://github.com/visionmedia/supertest), and [`Chai`](https://github.com/chaijs/chai) must be installed:

{% highlight bash %}
npm install mocha --save
npm install supertest --save
npm install chai --save
{% endhighlight %}

We can set up a script command to run tests by appending the following line to the `"scripts"` JSON of `package.json`:

{% highlight bash %}
"test": "./node_modules/.bin/mocha"
{% endhighlight %}

Create a `test` directory (necessary for mocha to run the tests).  In this directory, add JS files to by run as tests.  Tests must have following requirements at the top:

{% highlight javascript %}
// This is critical (to set the environment)
process.env.NODE_ENV = 'test';

var request = require('supertest');
var express = require('express');
var app = require('../app');

// Get the db
var sequelize = require(__ dirname + "/../models").sequelize;

// Assertions
var chai = require('chai');
var expect = chai.expect;
var should = chai.should();
{% endhighlight %}

In addition, each `describe` function must contain the following function to force-reset the DB before each `it` test:

{% highlight javascript %}
describe("Initial unit test", function () {

   // Clear + prepare the DB
  beforeEach(function (done) {
    // Syncs the db + clears it
    sequelize.sync({ force: true }).then(function (sequelize) {
      done();
    }).catch(function (err) {
      throw err;
    });
  });

  // All tests


});
{% endhighlight %}

Endpoint requests can be made according to this example:

{% highlight javascript %}
it("Should be successful signup", function (done) {
  userJson = {
    user: {
      firstName: "hello",
      lastName: "world",
      email: "hello2@world.com",
      password: "password"
    }
  }

  request(app)
    .post('/users/sign_up')
    .send(userJson)
    .end(function (err, res) {
      console.log(res.body);
      res.status.should.equal(200);
      done();
    });
});

{% endhighlight %}

Tests can be run by executing:

{% highlight bash %}
npm test
{% endhighlight %}
